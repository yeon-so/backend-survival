# 7-4. Relationship Mapping

> ### 학습 키워드
>
> * [Relationship Mapping](7-4.-relationship-mapping.md#relationship-mapping)
>   * [DDD의 Aggregate](7-4.-relationship-mapping.md#ddd-domain-driven-design-aggregate)
>   * [N + 1 problem](7-4.-relationship-mapping.md#n-+-1-problem)
> * `CascaseType.ALL`
> * `orphanRemoval`
> * Event Sourcing
> * JPA 어노테이션
>   * @OneToMany
>   * @JoinColumn

***

## Relationship Mapping

* 데이터 모델 Entity의 관계를 객체 참조로 간단히 활용할 수 있다. 일반적으로 DDD의 Aggregate를 구현하기 위해 CascadeType.ALL과 orphanRemoval=true를 함께 사용하는 것을 권장한다.

### DDD(Domain Driven Design)의 Aggregate

#### 개념

* 애그리거트(Aggregate)는 서로 관련이 있는 도메인 모델들의 집합을 말한다.

#### 특징

* 각 애그리거트에는 애그리거트 루트라는 도메인 엔티티가 하나씩 있다.
  * 애그리거트 루트 역할
    1. 애그리거트 내 속한 객체의 변경을 책임진다.
    2. 도메인 규칙에 따라 언제나 애그리거트 내 모든 도메인 모델들의 일관성 유지를 책임진다.
* 애그리거트는 DB에 도메인을 저장하거나 읽어들이는 단위이다.

#### 사용 시 주의점

* 하나의 트랜잭션에서 둘 이상의 애그리거트를 수정하는 것은 성능상 좋지 않아 피하는 것이 좋다.
  * 즉 하나의 애그리거트에서 다른 애그리거트를 변경하지 말아야 한다는 의미이며, 둘 이상의 변경이 필요할 경우 이벤트나 비동기를 사용한다.
* 하나의 애그리거트에서 다른 애그리거트를 참조 시 필드로 직접 참조하지 않고 id를 사용하여 Repository를 통해 간접 참조를 한다.
  * 이 때 N+1 문제를 해결하기 위해 조인 또는 Batch Size 등 별도 설정이 필요하다.

### N + 1 problem

#### 개념

* N + 1 문제란 첫 번째 쿼리를 날렸을 때 의도하지 않은 N번의 쿼리가 추가적으로 실행되는 것을 의미한다.

#### 특징

* JPA Reposity를 활용해 인터페이스 메소드를 호출 할 시 발생한다.(READ시)
* 1:N 또는 N:1 관계를 가진 엔티티를 조회할 때 발생한다.
* JPQL에서 만든 SQL을 통해 데이터를 조회할 때 발생한다.

#### N + 1 problem 발생 시기

1. JPA Fetch 전략(Fetch Type)이 EAGER(즉시 로딩)으로 데이터를 조회하는 경우
2. JPA Fetch 전략(Fetch Type)이 LAZY(지연 로딩)으로 데이터를 조회하는 경우

#### 해결 방법

1. Fetch Join(패치 조인) 사용&#x20;
   * 패치 조인은 JPQL에서 성능 개선 및 최적화를 위해 제공하는 기능으로 연관된 엔티티나 컬렉션을 한꺼번에 조회하는 역할을 하여 문제를 해결할 수 있다.
2. Batch Size 설정
   * 정한 Size만큼 데이터를 미리 로딩하여 문제를 해결한다.
   * 되도록이면 EAGER를 사용할 때 사용해야 한다.



***

## `CascaseType.ALL`

## `orphanRemoval`
